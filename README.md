# Debian9 + Docker + Python3 + Postgresql > DigitalOcean
## Скачиваем образ питона
```
docker ps #работающие докеры
docker images #готовые контейнеры в докер хабе
docker pull python:3 #скачиваем с докер хаба
docker run -it python:3 python
```
***-it** -- говорит что будем работать c запущенным контейнером в интерактивном режиме\
**python:3** -- указываем имя контейнера\
**python** -- указываем ту программу которую хотим запустить внутри контейнера*

## Ставим дополнительные зависимости
```
docker run -it python:3 pip install django #--proxy <proxy> --если через прокси
docker ps -a #смотрим историю

#после взять ID и посмотреть все файлы и зависимости
docker diff  <ID>

#после можно закомитить этот контейнер и создать образ
docker commit  <ID>  mydjango

#если теперь посмотреть появился новый образ mydjango
docker images | grep mydjango

#можем его запустить и работать сним
docker run -it mydjango django-admin.py --help
docker ps -a

#после каждого запуска, копятся новые слои изменений на файловой системе,поэтому не нужные надо удалять
docker rm <ID CONTAINER> <ID CONTAINER> <ID CONTAINER>

#можно запустить контейнер с очисткой --rm (чтобы Docker автоматически очищал контейнер и удалял файловую систему при выходе из контейнера )
docker run --rm -it mydjango django-admin.py --help
```

## Пробуем другой более удобный вариант
```
mkdir /opt/docker-workshop
cd /opt/docker-workshop

nano Dockerfile
#здесь последовательно описываем что мы хотим сделать
FROM python:3
RUN pip install django #--proxy <proxy>

#теперь можем собрать контейнер
docker build -t mydjango .
```
***-t** -- указываем имя контейнера\
**.** -- путь до дериктории где находится докер файл*

Если запустить через *docker run* он запуститься внутри контейнера, но мы хотим чтобы изменения сбрасывались в файловую систему хоста, для этого есть система томов(для постгреса или для разработки, когда меняеш код локально она изменялась и в контейнере, для работы с томами используется ключик **-v**

```
#для начало посмотрим что представляет из себя этот контейнер
docker run --rm -it mydjango bash

ls
#мы видим что находимся в корне образа, и если мы выполним какую нибудь команду нр: start project он создатся в корне проекта, это неудобно, поэтому создаем спец директорию
exit

nano Dockerfile
....
RUN mkdir /data
WORKDIR /data #программа которая будет запускаться, будет брать это в качестве корневой директории

#снова собираем
docker build -t mydjano .

#ели теперь проверить
docker run --rm -it mydjango bash 

#мы оказываемся в /data
ls
exit

#мы с пом-ю -v подбросим наш текущий директорий в /data в контейнере
docker run -v `pwd`:/data --rm -it mydjango django-admin.py startproject mynewproject
ls

#создался проект и видно что он создался и внашей директории хост системы
ls -la

#видно что права на проект рутовский, потому что внутри контейнера только один юззер рут
#можно поменять так: chown user:user ./ -R

#запускаем проект
docker run -v `pwd`:/data --rm -it mydjango ./mynewproject/manage.py runserver

#но чтобы иметь доступ к ниму, надо запустить след. образом
docker run -p 8000:8000 -v `pwd`:/data --rm -it mydjango ./mynewproject/manage.py runserver 0.0.0.0:8000
```
***0.0.0.0:8000** -- чтобы веб сервер слушал все интерфейсы
**-р 8000:8000** -- подбрасываем порты локальный:контейнер*

